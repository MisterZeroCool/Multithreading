                                  Синхронизация
    Когда два или более потока исполнения имеют доступ к одному совместно используемому
ресурсу, они нуждаются в гарантии, что ресурс будет одновременно использован только одним
потоком. Процесс, обеспечивающий такое поведение потоков исполнения, называется синхрони-
зацией.
    Ключом к синхронизации является понятие монитора. Монитор - это объект, используемый
в качестве взаимоисключающей блакировки. Только один поток исполнения может в одно и то же
время владелять монитором. Когда поток исполнения запрашивает блокировку, то говорят, что
он входит в монитор. Все другие потоки исполнения, пытающиеся войти в заблокированный мо-
нитор, будут приостановлены до тех пор, пока первый поток не выйдет из монитора. Обо всех
прочих по­ токах говорят, что они ожидают монитор. Поток, владеющий монитором, может, если
пожелает, повторно войти в него. Синхронизировать прикладной код можно двумя способами,
предусматривающими использование ключевого слова synchronized.
    У объектов имеются свои, неявно связанные с ними мониторы. Чтобы войти в монитор объ-
екта, достаточно вызвать метод, объявленный с модификатором доступа synchronized. Когда
поток исполнения оказывается в теле синхронизированного метода, все другие потоки исполне-
ния или любые другие синхронизированные методы, пытающиеся вызвать его для того же самого
экземпляра, вынуждены ожидать. Чтобы выйти из монитора и передать управление объектом дру-
гому ожидающему потоку исполнения, владелец монитора просто возвращает управление из син-
хронизированного метода.

ПРОГРАММА.(ОШИБКА В ПРОГРАММЕ)
    Приведенная программа состоит из трех простых классов. Первый из них, Callme, содержит
единственный метод call(). Этот метод принимает параметр msg типа String и пытается вывести
символьную строку msg в квадратных скобках. Любопытно отметить,что после того,как метод
са11() выводит открывающую ква­дратную скобку и символьную строку msg,он вызывает метод
Thread.sleep(1ООО), который приостанавливает текущий поток исполнения на одну секунду.
    Конструктор следующего класса, Caller, принимает ссылку на экземпляры классов Callme и
String, которые сохраняются в переменных target и msg со­ответственно. В этом конструкторе
создается также новый поток исполнения, в котором вызывается метод run() для данного объекта.
Этот поток запускается немедленно. В методе run() из класса Caller вызывается метод call()
для экземпляра target класса Callme, передавая ему символьную строку msg. И наконец, класс
Synch начинается с создания единственного экземпляра класса Callme и трех экземпляров класса
Caller с отдельными строками сообщения. Один и тот же экземпляр класса Callme передается
каждому конструктору Caller().

Результат выводимый программой.
Добро пожаловать [в синхронизированный [мир!]
]
]

    Как видите, благодаря вызову метода sleep() из метода call() удается переключиться на
исполнение другого потока. Это приводит к смешанному выводу трех строк сообщений. В данной
программе отсутствует механизм, предотвра­щающий одновременный вызов в потоках исполнения
одного и того же метода для того же самого объекта, или так называемое состояние гоник, пос-
кольку три потока соперничают за окончание метода. В данном примере применяется метод sleep(),
чтобы добиться повторяемости и наглядности получаемого эффекта. Но, как правило, состояние
гонок менее заметно и предсказуемо, поскольку труд­но предугадать, когда именно произойдет
переключение контекста. В итоге про­грамма может быть выполнена один раз правильно, а другой
раз - неправильно.
    Чтобы исправить главный недостаток данной программы, следует упорядичитъ доступ к методу
call(). Это означает, что доступ к этому методу из потоков исполнения следует разрешить только
по очереди. Для этого достаточно предварить объявление метода call() ключевым словом synchronized.
    Этим предотвращается доступ к методу call() из других потоков исполнения, когда он уже
используется в одном потоке. После ввода модификатора доступа synchronized в объявление метода
call() результат выполнения данной про­граммы будет выглядеть следующим образом:

[Добро пожаловать]
[в синхронизированный]
[мир!]

    Должен быть честен, и сказать что даже с использованием ключевого слова synchronized, слова выво-
дятся в таком порядке:
[Добро пожаловать]
[мир!]
[в синхронизированный]
    Поискав на форумах я не нашел решения данной поблемы, но нашел некоторые ответы программистов на
данный вопрос:

Цитата с Тостера
    "Не знаю, что там у Шилдта но этот код не будет работать, как вы рассказываете. Три потока стартуют
     и выполняют работу в рандомном порядке. То что они джойнятся в таком порядке - вообще никак не вли-
     яет. Возможно, это пример, как делать не надо."